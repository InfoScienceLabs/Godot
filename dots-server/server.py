#!/usr/bin/env python3
# -*- coding: utf-8 -*-


from flask import Flask, g, request, jsonify
from flask_httpauth import HTTPTokenAuth
# from werkzeug.utils import secure_filename
# from utils import getDroplets
from utils import getDroplets
from utils import create_droplet
from utils import destroy_droplet
from utils import get_regions
from apscheduler.schedulers.background import BackgroundScheduler
from datetime import datetime
from datetime import timedelta
from models import Feeder
from models import Unity
from models import Accounty

import logging
import secrets

import sentry_sdk
sentry_sdk.init("<DSN>")


# Create and configure logger
logging.basicConfig(filename="feeder.log",
                    format='%(asctime)s %(message)s',
                    filemode='w')
log = logging.getLogger()
log.setLevel(logging.INFO)

log.info("Application started!")

UPLOAD_FOLDER = './uploads'
ALLOWED_EXTENSIONS = {'json'}
app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
auth = HTTPTokenAuth(scheme='Bearer')


live_droplets = None
interval = 3
last_update = datetime.now()

locations = {}


def _updateRegions():
    global locations

    log.info("started updating regions")
    accounts = Accounty.select()
    for account in accounts:
        log.info(account.api_key)
        regions = get_regions(account.api_key)
        log.info(str(regions))
        locations[account.id] = regions
    log.info("finished updating regions")


def _init():
    # check for number of droplets if found less create droplets this shall be
    # by per account basis
    global locations
    accounts = Accounty.select()
    log.info("started droplet checks : {0} total accounts found".format(accounts.count()))
    for account in accounts:
        units = Unity.select().where(Unity.acid == account.id &  Unity.kill == False)
        if units.count() == account.total_units:
            # all good! continue
            # info log here if needed
            log.info("All good! sufficent droplets")
            continue
        else:
            # start creating droplets
            log.info("need to create droplets: "+str(account.total_units-units.count()))
            for x in range(1, (account.total_units-units.count())):
                # log here
                log.info("creating droplet: "+str(x))
                if(len(locations.get(account.id,[])) > 0):
                    create_droplet(account.api_key,
                                   image=account.snapid,
                                   region=secrets.choice(
                                                    locations.get(account.id)))
                # update status in the table
    log.info("finished droplet checks")
    pass


def monty():
    # info log here for monitoring timestamp
    log.info("started periodic monitoring")
    accounts = Accounty.select()
    for account in accounts:
        updates = getDroplets(account.api_key)
        for update in updates:
            unit = Unity.select().where(Unity.uid == update.get('id')).limit(1)
            if unit.count() == 1:
                unit = unit[0]
                unit.name = update.get('name')
                unit.region = update.get('region')
                unit.status = update.get('status')
                unit.name = update.get('name')
                unit.ip = update.get('ip')

                if unit.kill:
                    # log here that we are destroying the droplet
                    log.info("marked to kill:"+unit.ip)
                    destroy_droplet(account.api_key, unit.uid)
                    unit.status = "killed"
                    unit.killed = datetime.now()
                    # log here,we are creating a droplet to compensate the same
                    # or we need not do anything here as it will be created in
                    # next monitor event
                    pass

                unit.save()
            else:
                log.info("new droplet! : "+update.get('ip'))
                unit_block = Unity()
                unit_block.ip = update.get('ip')
                unit_block.name = update.get('name')
                unit_block.status = update.get('status')
                unit_block.region = update.get('region')
                unit_block.uid = update.get('id')
                unit_block.feeds = 100
                unit_block.acid = account.id
                unit_block.kill = False

                # try catch not required mostly since everything is being
                # generated by systems only
                unit_block.save()
    log.info("finished periodic monitoring")


def updateDroplets():
    global live_droplets
    global last_update
    live_droplets = getDroplets(dtok)
    last_update = datetime.now()
    # print(live_droplets)

log.info("running once during begning!")
# run once during begining
updateDroplets()
_updateRegions()
monty()
# _init()

log.info("finished initialization! adding schesuler jobs now")
# scheduled jobs
scheduler = BackgroundScheduler()
# JOB TO UPDATE STATUS EVERY 3 MINUTES
update_job = scheduler.add_job(updateDroplets, 'interval', minutes=interval)
# JOB TO MONITOR DROPLETS AND UPDATE STATUS IN DATABASE
monty_job = scheduler.add_job(monty, 'interval', minutes=5)
# JOB TO MONITOR DROPLETS AND CREATE OR DESTROY IF NEEDED
dropy_job = scheduler.add_job(_init, 'interval', minutes=8)
# JOB TO UPDATE AVAILABLE REGIONS TO CREATE DROPLETS
region_job = scheduler.add_job(_updateRegions, 'interval', minutes=30)
scheduler.start()

tokens = {
    "<KEY1>": "john",
    "<KEY2>": "susan"
}


def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS


@auth.verify_token
def verify_token(token):
    # print(request.remote_addr)
    if token in tokens:
        g.current_user = tokens[token]
        return True
    return False


@app.route('/')
@auth.login_required
def index():
    return "Hello, %s!" % g.current_user


@app.route('/notify/<int:nid>', methods=['GET', 'PUT'])
@auth.login_required
def notify(nid):
    if request.method == 'GET':
        if nid == 0:  # get_data
            limiter = Unity.select()\
                            .where(Unity.uid == int(request.args.get('uid')))\
                            .limit(1)

            if limiter.count() == 0:
                return {'status': 'unsuccessful', 'state': 'wait'}

            limiter = limiter[0].feeds
            dataset = Feeder.select()\
                            .where(Feeder.status == 'open')\
                            .limit(limiter)
            for data in dataset:
                data.ipaddr = request.remote_addr
                data.status = "active"
                data.assigned = datetime.datetime.now()
                data.save()
            return {'status': 'successful', 'data': tuple(dataset.tuples())}

        elif nid == 1:  # ipblocked
            up = Feeder.update(status="open")\
                .where((Feeder.ipaddr == str(request.remote_addr)) &
                       (Feeder.id >= int(request.args.get('set'))) &
                       (Feeder.status == "active"))
            up.execute()

            unit = Unity.select()\
                        .where(Unity.ip == request.remote_addr).limit(1)
            if unit.count() == 1:
                unit.kill = True
                unit.save()
                # marked to destroy the droplet
            else:
                # error log this case should never happen
                # this means that the ipaddress/ droplet is transmitting but
                # we dont have any account or any information of its existence
                pass
        elif nid == 2:
            up = Feeder.update(status="done")\
                .where(Feeder.id == request.args.get('set'))
            up.execute()
            #  to stopa droplet send if it ccan continue next url
            return {'status': 'successful', 'state': 'continue'}
            pass

    return {'status': 'successful'}


@app.route('/status/', methods=['GET'])
@auth.login_required
def status():
    if request.method == 'GET':
        return jsonify({'data': live_droplets, 'current_time': datetime.now(),
                        'update_interval(mins)': interval,
                        "last_update": last_update,
                        "next_update": last_update
                        + timedelta(minutes=interval)})


if __name__ == '__main__':
    app.run(debug=True, port=5050)

